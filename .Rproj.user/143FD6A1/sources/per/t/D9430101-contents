# selección de variables y correlación

library(corrplot)
library(Hmisc)
library(car)

# flattenCorrMatrix
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor  =(cormat)[ut],
    p = pmat[ut]
  )
}

data_amb<-read.csv("./data/Amb.csv")

names(data_amb)
rownames(data_amb)<-data_amb$ParcelaID
names(data_amb)[1]<-"PlotID"

#data_amb<-data_amb[,-c(1,2)]

names(data_amb)

res1<-rcorr(as.matrix(data_amb[,3:5]))
res2<-rcorr(as.matrix(data_amb[,9:17,33:44]))
res3<-rcorr(as.matrix(data_amb[,c(6:8,21:32)]))
res4<-rcorr(as.matrix(data_amb[,c(18:20)]))

flattenCorrMatrix(res1$r, res1$P)
corrplot(res1$r, type = "upper", order = "hclust",
         p.mat=res1$P , tl.col = "black",
         sig.level = 0.05,insig="blank")

flattenCorrMatrix(res2$r, res2$P)
corrplot(res2$r, type = "upper", order = "hclust",
         p.mat=res2$P , tl.col = "black",
         sig.level = 0.05,insig="blank")

flattenCorrMatrix(res3$r, res3$P)
corrplot(res3$r, type = "upper", order = "hclust",
         p.mat=res3$P , tl.col = "black",
         sig.level = 0.05,insig="blank")

flattenCorrMatrix(res4$r, res4$P)
corrplot(res4$r, type = "upper", order = "hclust",
         p.mat=res4$P , tl.col = "black",
         sig.level = 0.05,insig="blank")

data<-read.csv("./data/SXY.csv")

data<-droplevels(data[data$Type=="OS",])
data<-data.frame(PlotID=data$PlotID,
                 #Abtot=as.numeric(rowSums(data[,9:34])),
                 Abtot=as.numeric(rowSums(data[,9:34])>0))

data<-merge(data,data_amb,by="PlotID")

names(data_amb)

formula1 <- as.formula(
  paste("Abtot ~ ", paste(colnames(data_amb)[3:5], collapse = " + ")))
formula2 <- as.formula(
  paste("Abtot ~ ", paste(colnames(data_amb)[c(9:17,33:44)], collapse = " + ")))
formula3 <- as.formula(
  paste("Abtot ~ ", paste(colnames(data_amb)[c(6:8,21:32)], collapse = " + ")))
formula4 <- as.formula(
  paste("Abtot ~ ", paste(colnames(data_amb)[c(18:20)], collapse = " + ")))

# selección por grupo

step(glm(data=data,formula1),test="Chisq")
step(glm(data=data,formula2),test="Chisq")
step(glm(data=data,formula3),test="Chisq")
step(glm(data=data,formula4),test="Chisq")

#selecciono altitude porque tiene interés
# lat lon van a ir como random effects
# bio1 (annual mean temperature) 
# tot y 10 tienen resultados similares. elijo tot porque me parece que tiene más sentido
# bio12 (annual precipitation)
# tot y 10 tienen resultados similares. elijo tot porque me parece que tiene más sentido
# metmean (petmean, potential evapotranspiration)  

library(ggplot2)
names(data)

pdf("./panels/amb/var_amb.pdf")
for (i in 7:ncol(data)){
  print(ggplot(data,aes_string(x=quote(PlotID),y=(names(data[i]))))+
          geom_point())
}

for (i in 7:ncol(data)){
  print(ggplot(data,aes_string(y=quote(Abtot),x=(names(data[i]))))+
          geom_point())
}

dev.off()

# selección
sel<-c("Altitude","BIO1mean_4","BIO12mean_4","PPET1mean_4")

res5<-rcorr(as.matrix(data_amb[,sel]))
diag(res5$P)<-1

pdf("./panels/amb/var_amb_sel.pdf")

flattenCorrMatrix(res5$r, res5$P)
corrplot(corr=res5$r, 
         method="number",
         type = "upper", 
         order = "hclust",
         p.mat=res5$P , 
         tl.col = "black",
         sig.level = 0.05,
         insig="blank")



dev.off()

ggplot(data=data_amb,aes(x=Altitude,y=BIO1mean_4))+
         geom_point()
ggplot(data=data_amb,aes(x=Altitude,y=BIO12mean_4))+
  geom_point()
ggplot(data=data_amb,aes(x=Altitude,y=PPET1mean_4))+
  geom_point()


data[,c("Abtot",sel)]
model<-glm(data=data,Abtot~Altitude+BIO1mean_4+BIO12mean_4+PPET1mean_4,family=binomial(link = logit))
anova(model,test="Chisq") 

model<-glm(data=data,Abtot~Altitude+BIO1mean_4+BIO12mean_4,family=binomial(link = logit))
anova(model,test="Chisq") 

model<-glm(data=data,Abtot~Altitude+BIO12mean_4,family=binomial(link = logit))
anova(model,test="Chisq") 

model<-glm(data=data,Abtot~Altitude,family=binomial(link = logit))
anova(model,test="Chisq") 

summary(model)

# VIF
# Check for multicollinearity among covariates
vif <- vif(model)
# Print the results on the screen
print(vif)

# Rhelp:vif. 
# The VIF for predictor i is 1/(1-R_i^2), where R_i^2 is the R^2 from a 
# regression of predictor i against the remaining predictors. 
# If R_i^2 is close to 1, this means that predictor i is well explained by a 
# linear function of the remaining predictors, and, therefore, 
# the presence of predictor i in the model is redundant. 
# Values of VIF exceeding 5 are considered evidence of collinearity: 
# The information carried by a predictor having such a VIF is contained 
# in a subset of the remaining predictors. 
# If, however, all of a model's regression coefficients differ significantly 
# from 0 (p-value < .05), a somewhat larger VIF may be tolerable.



# el mejor modelo es Altitude + BIO12 (PP). AIC 140.
data_amb<-data_amb[,c("PlotID","Lon","Lat",sel)]

names(data_amb)[5:7]<-c("Temperature","Precipitation","PPET")

write.csv(data_amb,
          "./data/Amb.csv",row.names = F)
